use serde::{Serialize, Deserialize};
use mongodb::bson::{self, oid::ObjectId, DateTime};

/// Report type
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum ReportType {
    Daily,
    Weekly,
    Monthly,
    Custom,
    Incident,
}

/// Report status
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum ReportStatus {
    Pending,
    InProgress,
    Completed,
    Failed,
}

/// Report format
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum ReportFormat {
    PDF,
    CSV,
    JSON,
    HTML,
}

/// Represents a security report
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Report {
    /// MongoDB ID
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,

    /// Report ID
    pub report_id: String,

    /// Report title
    pub title: String,

    /// Report type
    pub report_type: ReportType,

    /// Report status
    pub status: ReportStatus,

    /// Report format
    pub format: ReportFormat,

    /// Generated by
    pub generated_by: String,

    /// Generated at
    pub generated_at: DateTime,

    /// Report period start
    pub period_start: DateTime,

    /// Report period end
    pub period_end: DateTime,

    /// File path (if generated)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file_path: Option<String>,

    /// Error message (if failed)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,

    /// Contains report statistics and data
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<ReportData>,
}

/// Report data
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReportData {
    /// Total alerts
    pub total_alerts: u64,

    /// Alerts by severity
    pub alerts_by_severity: bson::Document,

    /// Alerts by status
    pub alerts_by_status: bson::Document,

    /// Alerts by date
    pub alerts_by_date: bson::Document,

    /// Top source IPs
    pub top_source_ips: Vec<IpCount>,

    /// Top destination IPs
    pub top_destination_ips: Vec<IpCount>,

    /// Alerts by protocol
    pub alerts_by_protocol: bson::Document,

    /// Alert IDs included in the report
    pub alert_ids: Vec<String>,
}

/// IP address count for reports
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IpCount {
    /// IP address
    pub ip: String,

    /// Count
    pub count: u64,

    /// Country code (if available)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub country: Option<String>,
}

/// Report generation request
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReportRequest {
    /// Report type
    pub report_type: ReportType,

    /// Report format
    pub format: ReportFormat,

    /// Report title (optional)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,

    /// Custom period start (for custom reports)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub period_start: Option<bson::DateTime>,

    /// Custom period end (for custom reports)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub period_end: Option<bson::DateTime>,

    /// Incident ID (for incident reports)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incident_id: Option<String>,

    /// User who requested the report
    pub generated_by: String,
}

impl Report {
    /// Create a new report
    pub fn new(
        report_id: String,
        title: String,
        report_type: ReportType,
        format: ReportFormat,
        generated_by: String,
        period_start: bson::DateTime,
        period_end: bson::DateTime,
    ) -> Self {
        Self {
            id: None,
            report_id,
            title,
            report_type,
            status: ReportStatus::Pending,
            format,
            generated_by,
            generated_at: bson::DateTime::now(),
            period_start,
            period_end,
            file_path: None,
            error: None,
            data: None,
        }
    }

    /// Set report status to in progress
    pub fn set_in_progress(&mut self) {
        self.status = ReportStatus::InProgress;
    }

    /// Set report status to completed
    pub fn set_completed(&mut self, file_path: Option<String>, data: Option<ReportData>) {
        self.status = ReportStatus::Completed;
        self.file_path = file_path;
        self.data = data;
    }

    /// Set report status to failed
    pub fn set_failed(&mut self, error: String) {
        self.status = ReportStatus::Failed;
        self.error = Some(error);
    }
}